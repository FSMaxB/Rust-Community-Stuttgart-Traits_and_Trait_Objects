<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" type="image/svg+xml" href="favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Vite App</title>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Traits and Trait Objects</h1>
					<h2>More than just interfaces</h2>
					<h3>Max Bruckner</h3>
				</section>
				<section>
					<section>
						<h2>What is a trait?</h2>
					</section>
					<section>
						<h2>What is a trait?</h2>
						<ul>
							<li>Interface?</li>
							<li>Type class?</li>
							<li>Collection of methods?</li>
							<li>Shared behavior</li>
						</ul>
					</section>
					<section>
						<h2>Example</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout {
									fn shout();
								}
							</script>
						</code></pre>
					</section>
					<section>
						Traits are implemented from outside of the type itself. <em>(attached to it)</em>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Dog;

								impl Shout for Dog {
									fn shout() {
										println!("Whoof!");
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Example</h3>
						<div class="fragment">
							<p><em>Duration types from different sources.</em></p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Days(u16);
								struct Seconds(u64);
								use std::time::Duration;
							</script>
						</code></pre>
						</div>
						<p class="fragment"><em>You're interested in the number of days.</em></p>
						<div class="fragment">
							<p>Traditional solution:</p>
							<p> Wrapper type that implements an interface</p>
						</div>
					</section>
					<section>
						<h2>Example</h2>
						<p>Trait solution:</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Duration {
									fn days(&self) -> u64;
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl Duration for Days {
									fn days(&self: Days) -> u64 { self.0 as u64 }
								}

								impl Duration for Seconds {
									fn days(&self: Seconds) -> u64 { self.0 / (24 * 3600) }
								}

								impl Duration for std::time::Duration {
									fn days(&self: std::time::Duration) -> u64 {
										self.as_secs() / (24 * 3600)
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						Traits can have default implementations.

						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout {
									fn shout() {
										println!("The sound of silence!");
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Super traits</h2>
						<p>Traits can require other traits (similar to inheritance)</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout: ToString {
									fn shout(&self) {
										println!("Shouting: {}!", self.to_string());
									}
								}
							</script>
						</code></pre>
						<div class="fragment">
							<p>For multiple traits, use <code>+</code>, e.g.: </p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout: Clone + ToString {
									...
								}
							</script>
						</code></pre>
						</div>

					</section>
					<section>
						Traits can be implemented on <b>any</b> type.

						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl Shout for i32 {
									fn shout() {
										println!("Aren't numbers silent?")
									}
								}
							</script>
						</code></pre>
						<p class="fragment">Yes, even primitive types</p>
						<p class="fragment">Most notably: <b>Types you didn't define yourself</b></p>
					</section>
					<section>
						Traits can even be implemented on generic types.
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Identity {
									fn identity(self) -> Self;
								}
							</script>
						</code></pre>

						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<T> Identity for T {
									fn identity(self) -> T {
										self
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Limits</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl std::fmt::Display for () {
									...
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers>
							<script type="text/template">
								error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
								--> src/main.rs:1:1
								|
								1 | impl std::fmt::Display for () {
								| ^^^^^^^^^^^^^^^^^^^^^^^^^^^--
								| |                          |
								| |                          this is not defined in the current crate because tuples are always foreign
								| impl doesn't use only types from inside the current crate
								|
								= note: define and implement a trait or new type instead
							</script>
						</code></pre>
					</section>

					<section>
						<h2>Orphan ruleÂ¹</h2>
						<p>You can implement</p>
						<p><ul>
							<li class="fragment"><em>Local</em> traits on any type</li>
							<li class="fragment"><em>Foreign</em> traits on <em>local</em> types</li>
						</ul></p>
						<p class="fragment">This prevents ambiguous implementations.</p>
						<p><small>Â¹simplified, see <a href="https://doc.rust-lang.org/stable/reference/items/implementations.html?highlight=orphan%20rule#orphan-rules">the reference</a></small></p>
					</section>
					<section>
						<h2>Overlap</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
									impl<T> Identity for T {
										fn identity(self) -> Self {
											self
										}
									}

									impl Identity for i32 {
										fn identity(self) -> Self {
											self
										}
									}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers>
							<script type="text/template">
							error[E0119]: conflicting implementations of trait `Identity` for type `i32`
							--> src/main.rs:7:1
							|
							1 | impl<T> Identity for T {
								| ---------------------- first implementation here
							...
							7 | impl Identity for i32 {
								| ^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `i32`
							</script>
						</code></pre>
					</section>
					<section>
						<h2>How can I use my trait methods</h2>
						<div class="fragment">
							<h3>Static trait methods</h3>
							<pre><code data-trim data-noescape data-line-numbers>
							<script type="text/template">
								use crate::Shout; // import required

								Dog::shout();
								<Dog as Shout>::shout();
							</script>
							</code></pre>
						</div>
						<div class="fragment">
							<h3>Methods with <code>self</code></h3>
							<pre><code data-trim data-noescape data-line-numbers>
							<script type="text/template">
								use std::string::ToString; // import required (in general)

								1.to_string();
								i32::to_string(&1);
								<i32 as ToString>::to_string(&1);
							</script>
							</code></pre>
						</div>
					</section>
				</section>
				<section>
					<section>
						<h2>Generics</h2>
					</section>
					<section>
						<h2>Trait bounds</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print<T>(value: T)
								where
									T: ToString,
								{
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								pub fn main() {
									print(1);
									print("hello");
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Trait bounds</h2>
						<ul>
							<li class="fragment">Similar to Generic Bounds in Java, TypeScript etc.
								<ul class="fragment">
									<li>Only properties of the traits can be used</li>
								</ul>
							</li>
							<li class="fragment">Other than e.g. C++ concepts
								<ul>
									<li>Only constrains callers, but duck typing still possible</li>
								</ul>
							</li>
						</ul>
						<em class="fragment"><a href="https://www.youtube.com/watch?v=E-2y1qHQvTg">Conor Hoekstra - Concepts vs Typeclasses vs Traits vs Protocols</a></em>
					</section>
					<section>
						<h2>Syntactic sugar</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print<T: ToString>(value: T) {
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: impl ToString) {
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<p><em class="fragment"><code>impl</code> is <a href="https://doc.rust-lang.org/stable/reference/types/impl-trait.html?highlight=impl%20trait#anonymous-type-parameters">not exactly</a> equivalent though</em></p>
						<p><em class="fragment">Also <code>impl</code> only works in functions and methods</em></p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer() -> impl Fn(&str) {
									|text| println!("{}", text)
								}
							</script>
						</code></pre>
						<p class="fragment"><em>Supports returning unnameable types (like closures)</em></p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> impl Fn(&str) {
									if stdout {
										|text| println!("{}", text)
									} else {
										|text| eprintln!("{}", text)
									}
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error: implementation of `FnOnce` is not general enough
								--> src/main.rs:1:34
								|
								1 | fn make_printer(stdout: bool) -> impl Fn(&str) {
								|                                  ^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough
								|
								= note: `fn(&'2 str)` must implement `FnOnce<(&'1 str,)>`, for any lifetime `'1`...
								= note: ...but it actually implements `FnOnce<(&'2 str,)>`, for some specific lifetime `'2`
							</script>
						</code></pre>
						<p class="fragment">Every path needs to return the same type.</p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> impl Fn(impl ToString) {
									|text| println!("{}", text.to_string())
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0666]: nested `impl Trait` is not allowed
								--> src/main.rs:1:30
								|
								1 | fn make_printer() -> impl Fn(impl ToString) {
								|                      --------^^^^^^^^^^^^^-
								|                      |       |
								|                      |       nested `impl Trait` here
								|                      outer `impl Trait`
							</script>
						</code></pre>
						<p class="fragment">Only <b>concrete</b> types are supported</p>
					</section>
					<section>
						<p>Both of these problems can be fixed using trait objects.</p>
						<p>More on that later.</p>
					</section>
					<section>
						<h2>Marker traits</h2>
						<p>Traits without methods etc. just for use in bounds</p>
						<div class="fragment">
							<p>Example:</p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
								<script type="text/template">
									unsafe trait Send {}
								</script>
							</code></pre>
							<p><em>Marks types that can be transfered across thread boundaries.</em></p>
						</div>
					</section>
					<section>
						<h2>Marker traits</h2>
						<pre>std::thread::spawn</pre>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
								<script type="text/template">
									pub fn spawn<T, T>(f: F) -> JoinHandle<T>
									where
										F: FnOnce() -> T,
										F: Send + 'static,
										T: Send + 'static,
								</script>
							</code></pre>
						<p class="fragment"><code>Send</code> bound ensures no thread unsafe type can be passed to another thread.</p>
						<div class="fragment">
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
									<script type="text/template">
										let rc = Rc::new(1);
										std::thread::spawn(|| println!("{}", rc));
									</script>
								</code></pre>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
									<script type="text/template">
										error[E0277]: `Rc<i32>` cannot be shared between threads safely
											â€¦
									</script>
								</code></pre>
						</div>
					</section>
					<section>
						<h2>Auto traits</h2>
						<p><code>Send</code> is also an auto trait, it automatically gets implemented by the compiler</p>
						<p class="fragment">Others: <code>Sync</code>, <code>Unpin</code>, <code>UnwindSafe</code>, <code>RefUnwindSafe</code></p>
					</section>
					<section>
						<p>How is code generated from generics?</p>
					</section>
					<section>
						<h2>Monomorphisation</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: impl ToString) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print(1);
									print("hello");
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Monomorphisation</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print_i32(value: i32) {
									println!("{}", value.to_string());
								}

								fn print_str(value: &str) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print_i32(1);
									print_str("hello");
								}
							</script>
						</code></pre>
						<p>Monomorphisation = Polymorphic -> Monomorphic</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Small intermezzo</h2>
					</section>
					<section>
						<h2>Generic types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Wrapper<Wrapped> {
									wrapped: Wrapped,
								}
							</script>
						</code></pre>
						<p class="fragment">You could constrain the type definition</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Wrapper<Wrapped: Default> {
									wrapped: Wrapped,
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Generic types</h2>
						<p>But you might want to only constrain implementations</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<Wrapped: Default> Default for Wrapper<Wrapped> {
									fn default() -> Self {
										Self {
											wrapped: Wrapped::default(),
										}
									}
								}
							</script>
						</code></pre>
						<p class="fragment">This is a conditional trait implementation.</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								// useful for e.g.
								let value: Arc<Mutex<MyType> = Arc::default();
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Generic Types</h2>
						<p>This also works for regular <code>impl</code> blocks</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<Wrapped: ToString> Wrapper<Wrapped> {
									fn print(&self) {
										println!("Wrapper({})", self.wrapped.to_string());
									}
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								Wrapper { wrapped: () }.print();
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0599]: the method `print` exists for struct `Wrapper<()>`, but its trait bounds were not satisfied
								--> src/main.rs:12:26
								|
								1  | struct Wrapper<Wrapped> {
									 | ----------------------- method `print` not found for this
								...
								12 |     Wrapper { wrapped: () }.print();
									 |                             ^^^^^ method cannot be called on `Wrapper<()>` due to unsatisfied trait bounds
									 |
									 = note: the following trait bounds were not satisfied:
													 `(): ToString`
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Conditional trait methods</h2>
						<p>Also works on trait methods themselves</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout {
									fn shout();
									fn debug(&self)
									where
										Self: Debug {
										println!("{:?}", self);
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Deriving traits</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								#[derive(Default, Clone)]
								struct Wrapper<Wrapped> {
									wrapped: Wrapped,
								}
							</script>
						</code></pre>
						<p>Automatically adds implementation for some builtin traits if all members also implement it.</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								let wrapped_number = Wrapper::<i32>::default();
								let clone = wrapped_number.clone();
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Deriving traits</h2>
						<p>Using procedural macros, can be implemented yourself or by libraries.</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								use serde::{Serialize, Deserialize};

								#[derive(Serialize, Deserialize)]
								struct Point {
									x: f64,
									y: f64,
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
									let json = r#"{"x":1.0,"y":2.0}"#;
									let point = serde_json::from_str(json).unwrap();
									assert_eq!(Point { x: 1.0, y: 2.0 }, point);
									let printed_json = serde_json::to_string(&point).unwrap();
									assert_eq!(json, printed_json);
							</script>
						</code></pre>
					</section>
					<section>
						<h2>End of Intermezzo</h2>
					</section>
				</section>
				<section>
					<section>
						<h2>Trait Objects</h2>
					</section>
					<section>
						<h2>So far</h2>
						<ul>
							<li class="fragment">Monomorphisation
								<ul>
									<li>static dispatch</li>
									<li>copied implementation for every type</li>
								</ul>
							</li>
							<li class="fragment">good optimization opportunities</li>
							<li class="fragment">Can't return multiple types</li>
							<li class="fragment">Can't nest <code>impl</code></li>
						</ul>
					</section>
					<section>
						<h2>With trait objects</h2>
						<ul>
							<li class="fragment">dynamic dispatch</li>
							<li class="fragment">stops generics propagation
								<ul>
									<li class="fragment">faster compile times</li>
								</ul>
							</li>
							<li class="fragment">smaller binaries</li>
							<li class="fragment">returning different trait implementations</li>
							<li class="fragment">type erasure</li>
						</ul>
					</section>
					<section>
						<h2>Trait Objects</h2>
						<p>Works like in most popular languages</p>
						<ul>
							<li class="fragment"><b>One</b> dynamic implementation for every type</li>
							<li class="fragment">Java Interfaces</li>
							<li class="fragment">(virtual) inheritance</li>
						</ul>
					</section>
					<section>
						<h2>Owned</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: Box<dyn ToString>) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print(Box::new(1));
									print(Box::new("hello"));
								}
							</script>
						</code></pre>
						<p class="fragment">Also works with <code>Rc</code>, <code>Arc</code>, etc.</p>
						<p class="fragment"><em>Always requires heap allocation!</em></p>
					</section>
					<section>
						<h2>Borrowed</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: &dyn ToString) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print(&1);
									print(&"hello");
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Type Erasure</h2>
						<p>This now works</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> Box<dyn Fn(&str)> {
									if stdout {
										Box::new(|text| println!("{}", text.to_string()))
									} else {
										Box::new(|text| eprintln!("{}", text.to_string()))
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Nested <code>dyn</code></h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> Box<dyn Fn(&dyn ToString)> {
									if stdout {
										Box::new(|text| println!("{}", text.to_string()))
									} else {
										Box::new(|text| eprintln!("{}", text.to_string()))
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>What IS a trait object?</h2>
						<div class="fragment">
							<p>NOTE: Deprecated <a href="https://doc.rust-lang.org/stable/std/raw/struct.TraitObject.html">std::raw::TraitObject</a>, for demonstration only</p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
								<script type="text/template">
									#[repr(C)]
									pub struct TraitObject {
										pub data: *mut (),
										pub vtable: *mut (),
									}
								</script>
							</code></pre>
						</div>
						<ul>
							<li class="fragment">Data pointer
								<ul>
									<li>points to actual value</li>
									<li>same as normal references</li>
								</ul>
							</li>
							<li class="fragment">VTable pointer
								<ul>
									<li>points to metadata about the type</li>
								</ul>
							</li>
						</ul>
					</section>
					<section>
						<h2>VTable</h2>
						<img src="images/vtable-debugger.png"/>
						<p><em><a href="https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler/rustc_middle/src/ty/vtable.rs#L8-L22">NOTE: Unstable internals</a></em></p>
						<ul>
							<li>size</li>
							<li>alignment</li>
							<li>methods</li>
							<li>super trait vtable references</li>
						</ul>
					</section>
					<section>
						<h2>Object Safety</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn takes_default(value: Box<dyn Default>) {
									unimplemented!()
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0038]: the trait `Default` cannot be made into an object
								--> src/main.rs:1:25
								|
								1 | fn takes_default(value: Box<dyn Default>) {
									|                         ^^^^^^^^^^^^^^^^ `Default` cannot be made into an object
									|
									= note: the trait cannot be made into an object because it requires `Self: Sized`
									= note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>
							</script>
						</code></pre>
						<p class="fragment">Not all traits can be used as trait objects.</p>
					</section>
					<section>
						<h2><a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">Object safety</a></h2>
						<ol>
							<li class="fragment">supertraits must be object safe</li>
							<li class="fragment">must not require <code>Sized</code></li>
							<li class="fragment">must not have associated constants</li>
							<li class="fragment">methods must not be generic</li>
							<li class="fragment">methods must not use the <code>self</code> receiver
								<ul>
									<li><code>&self</code>, <code>Box&lt;Self&gt;</code> etc. are okay</li>
								</ul>
							</li>
							<li class="fragment">methods must have a receiver</li>
							<li class="fragment">methods must not use the <code>Self</code> type</li>
							<li class="fragment">methods must not be constrained by <code>where Self: Sized</code></li>
						</ol>
					</section>
					<section>
						<h2>But why?</h2>
					</section>
					<section>
						<ol start="1">
							<li>supertraits must be object safe</li>
						</ol>
						<p class="fragment"><em>a trait has all properties of a supertrait</em></p>
					</section>
					<section>
						<ol start="2">
							<li>must not require <code>Sized</code></li>
						</ol>
						<p class="fragment"><em>every implementation could have a different size</em></p>
						<p class="fragment">Trait objects are DSTs (dynamically sized types)</p>
					</section>
					<section>
						<ol start="3">
							<li>must not have associated constants</li>
						</ol>
					</section>
					<section>
						<h2>Associated constants</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait LimitedNumber {
									const MIN_VALUE: usize;
									const MAX_VALUE: usize;
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl LimitedNumber for u8 {
									const MIN_VALUE: usize = u8::MIN as usize;
									const MAX_VALUE: usize = u8::MAX as usize;
								}

								impl LimitedNumber for u64 {
									const MIN_VALUE: usize = u64::MIN as usize;
									const MAX_VALUE: usize = u64::MAX as usize;
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								println!("u8 min: {}", u8::MIN_VALUE);
								println!("u64 max: {}", u64::MAX_VALUE);
							</script>
						</code></pre>
					</section>
					<section>
						<ol start="3">
							<li>must not have associated constants</li>
						</ol>
						<p class="fragment"><em>every implementation could have a different constant</em></p>
						<p class="fragment"><em>therefore not available at compile time</em></p>
					</section>
					<section>
						<ol start="4">
							<li>methods must not be generic</li>
						</ol>
						<p class="fragment"><em>generic methods have infinite implementations</em></p>
						<p class="fragment"><em>the vtable can only store one</em></p>
					</section>
					<section>
						<ol start="5">
							<li class="fragment">methods must not use the <code>self</code> receiver
								<ul>
									<li><code>&self</code>, <code>Box&lt;Self&gt;</code> etc. are okay</li>
								</ul>
							</li>
						</ol>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Foo {
									fn takes_self(self);
								}
							</script>
						</code></pre>
						<div class="fragment">
							<p><em>hidden <code>Sized</code> bound</em></p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Foo {
									fn takes_self(self: Self)
									where
										Self: Sized;
								}
							</script>
						</code></pre>
						</div>
						<p class="fragment"><em>Method needs to allocate stack space for <code>self</code></em></p>
						<p class="fragment">the other receivers are just references, therefore fixed size</p>
					</section>
					<section>
						<ol start="6">
							<li>methods must have a receiver</li>
						</ol>
						<p class="fragment"><em>methods without receiver don't have a reference to <code>self</code></em></p>
						<div class="fragment">
							<p><em>therefore no access to a vtable</em></p>
							<p><em>(and the methods therein)</em></p>
						</div>
					</section>
					<section>
						<ol start="7">
							<li>methods must not use the <code>Self</code> type</li>
							<li>methods must not be constrained by <code>where Self: Sized</code></li>
						</ol>
						<p class="fragment"><em>Same hidden <code>Sized</code> bound as with <code>self</code> receiver</em></p>
					</section>
					<section>
						<h2>Is my trait object safe?</h2>
						<p class="fragment">Check with the <code>assert_obj_safe</code> macro from the <a href="https://docs.rs/static_assertions">static_assertions</a> crate</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								assert_obj_safe!(Default);
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0038]: the trait `Default` cannot be made into an object
								--> src/main.rs:2:1
								|
								2 | assert_obj_safe!(Default);
								| ^^^^^^^^^^^^^^^^^^^^^^^^^^ `Default` cannot be made into an object
								|
								= note: the trait cannot be made into an object because it requires `Self: Sized`
								= note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>
								= note: this error originates in the macro `assert_obj_safe` (in Nightly builds, run with -Z macro-backtrace for more info)
							</script>
						</code></pre>
					</section>
					<section>
						<h2>You choose</h2>
						<ul>
							<li class="fragment"><em>You can choose between static and dynamic dispatch for the same type</em></li>
							<li class="fragment">Examples from other languages
								<ul>
									<li class="fragment">Java, Swift etc.: Always dynamic</li>
									<li class="fragment">C++: Depends on type (<code>virtual</code> methods)</li>
								</ul>
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Generic traits</h2>
						<p class="fragment"><em>Where the power lies!</em></p>
					</section>
					<section>
						<h3>The <code>From</code> trait</h3>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								pub trait From<T> {
									fn from(T) -> Self;
								}
							</script>
						</code></pre>
						<p>Can be implemented for every <code>T</code> separately</p>
					</section>
					<section>
						<h3>Example</h3>
						<p>Our <code>Duration</code> from earlier, but not as trait</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								// foreign types
								struct Days(u16);
								struct Seconds(u64);
								// std::time::Duration;

								// our type
								struct Duration {
									days: u64,
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Example</h3>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl From<Days> for Duration {
									fn from(days: Days) -> Duration {
										Self { days: days.0 as u64 }
									}
								}
							</script>
						</code></pre>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl From<Seconds> for Duration {
									fn from(seconds: Seconds) -> Duration {
										Self { days: seconds.0 / (24 * 3600)}
									}
								}
							</script>
						</code></pre>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl From<std::time::Duration> for Duration {
									fn from(duration: std::time::Duration) -> Duration {
										Self { days: duration.as_secs() / (24 * 3600)}
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Implement one, get one free</h3>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								pub trait Into<T> {
									fn into(self) -> T;
								}
							</script>
						</code></pre>
						<p class="fragment">ðŸ§™ <em>Let me implement this for you!</em></p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<T, U> Into<U> for T
								where
									U: From<T>
								{
									fn into(self) -> U {
										U::from(self)
									}
								}
							</script>
						</code></pre>
						<p class="fragment">All of our <code>From</code> implementations just got <code>Into</code> for free</p>
					</section>
					<section>
						<h3>Back to our example</h3>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print_days(duration: impl Into<Duration>) {
									let duration = duration.into();
									println!("{} day(s)", duration.days);
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								print_days(Days(10));
								print_days(Seconds(3_628_800));
								print_days(std::time::Duration::from_secs(3_628_800));
							</script>
						</code></pre>
					</section>
					<section>
						<em>Maybe we don't want all that monomorphization</em>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print_days(duration: Duration) {
									println!("{} day(s)", duration.days);
								}
							</script>
						</code></pre>
						<div class="fragment">
							<p><em>Voila</em></p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								print_days(Days(10).into());
								print_days(Seconds(3_628_800).into());
								print_days(std::time::Duration::from_secs(3_628_800).into());
							</script>
						</code></pre>
						</div>
						<p class="fragment">This makes converting between types quite convenient.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Associated types</h2>
					</section>
					<section>
						<h3>The <code>Deref</code> trait</h3>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							pub trait Deref {
								type Target: ?Sized; //special ?Sized

								fn deref(&self) -> &Self::Target;
							}
						</code></pre>
						<p><em>Can only be implemented once for any given type</em></p>
					</section>
					<section>
						<h3>Example: <code>Vec</code></h3>
						<p><em>(simplified)</em></p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<T> Deref for Vec<T> {
									type Target = [T];

									fn deref(&self) -> &[T] {
										self.as_slice()
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h3><code>Deref</code> vs. <code>AsRef</code></h3>
						<ul>
							<li class="fragment"><code>Deref</code> is THE implementation for dereferencing. There can only be one.</li>
							<li class="fragment"><code>AsRef</code> Can be implemented multiple times to dereference as separate types.
								<ul>
									<li>e.g. <code>String</code> is <code>AsRef&lt;[u8]&gt;</code> and <code>AsRef&lt;str&gt;</code></li>
								</ul>
							</li>
						</ul>
					</section>
					<section>
						<h3>The <code>Iterator</code> trait</h3>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								pub trait Iterator {
									type Item;

									fn next(&mut self) -> Option<Self::Item>;
									// ... a bunch of default implemented methods
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Operator overloading</h3>
						<p>Example:</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								pub trait Add<Rhs = Self> {
									type Output;
									fn add(self, rhs: Rhs) -> Self::Output;
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Point {
									x: f64,
									y: f64,
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Operator overloading</h3>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl Add for Point {
									type Output = Point;

									fn add(self, rhs: Self) -> Self::Output {
										Point {
											x: self.x + rhs.x,
											y: self.y + rhs.y,
										}
									}
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl Add<f64> for Point {
									type Output = Point;

									fn add(self, rhs: f64) -> Self::Output {
										Point {
											x: self.x + rhs,
											y: self.y + rhs,
										}
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Operator Overloading</h3>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								let a = Point {x: 1.0, y: 2.0};
								let b = Point {x: 3.0, y: 4.0};
								assert_eq!(Point {x: 4.0, y: 6.0}, a + b);
								assert_eq!(Point {x: 43.0, y: 44.0}, a + 42.0);
							</script>
						</code></pre>
					</section>
				</section>
				<section>
					<h2>End</h2>
					<p>Slides</p>
					<p><a href="https://github.com/FSMaxB/Rust-Community-Stuttgart-Traits_and_Trait_Objects">https://github.com/FSMaxB/Rust-Community-Stuttgart-Traits_and_Trait_Objects</a></p>
					<p></p>
					<p>Recording (once ready)</p>
					<p><a href="https://www.youtube.com/user/OSSMaxB">https://www.youtube.com/user/OSSMaxB</a></p>
				</section>
			</div>
		</div>
		<script type="module" src="/main.js"></script>
	</body>
</html>

<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" type="image/svg+xml" href="favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Vite App</title>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Traits and Trait Objects</h1>
					<h2>More than just interfaces</h2>
					<h3>Max Bruckner</h3>
				</section>
				<section>
					<section>
						<h2>What is a trait?</h2>
					</section>
					<section>
						<h2>What is a trait?</h2>
						<ul>
							<li>Interface?</li>
							<li>Type class?</li>
							<li>Collection of methods?</li>
							<li>Shared behavior</li>
						</ul>
					</section>
					<section>
						<h2>Example</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout {
									fn shout();
								}
							</script>
						</code></pre>
					</section>
					<section>
						Traits are implemented from outside of the type itself. <em>(attached to it)</em>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Dog;

								impl Shout for Dog {
									fn shout() {
										println!("Whoof!");
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h3>Example</h3>
						<div class="fragment">
							<p><em>Duration types from different sources.</em></p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Days(u16);
								struct Seconds(u64);
								use std::time::Duration;
							</script>
						</code></pre>
						</div>
						<p class="fragment"><em>You're interested in the number of days.</em></p>
						<div class="fragment">
							<p>Traditional solution:</p>
							<p> Wrapper type that implements an interface</p>
						</div>
					</section>
					<section>
						<h2>Example</h2>
						<p>Trait solution:</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Duration {
									fn days(&self) -> u64;
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl Duration for Days {
									fn days(&self: Days) -> u64 { self.0 as u64 }
								}

								impl Duration for Seconds {
									fn days(&self: Seconds) -> u64 { self.0 / (24 * 3600) }
								}

								impl Duration for std::time::Duration {
									fn days(&self: std::time::Duration) -> u64 {
										self.as_secs() / (24 * 3600)
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						Traits can have default implementations.

						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout {
									fn shout() {
										println!("The sound of silence!");
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						Traits can be implemented on <b>any</b> type.

						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl Shout for i32 {
									fn shout() {
										println!("Aren't numbers silent?")
									}
								}
							</script>
						</code></pre>
						<p class="fragment">Yes, even primitive types</p>
						<p class="fragment">Most notably: <b>Types you didn't define yourself</b></p>
					</section>
					<section>
						Traits can even be implemented on generic types.
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Identity {
									fn identity(self) -> Self;
								}
							</script>
						</code></pre>

						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<T> Identity for T {
									fn identity(self) -> T {
										self
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Limits</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl std::fmt::Display for () {
									...
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers>
							<script type="text/template">
								error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
								--> src/main.rs:1:1
								|
								1 | impl std::fmt::Display for () {
								| ^^^^^^^^^^^^^^^^^^^^^^^^^^^--
								| |                          |
								| |                          this is not defined in the current crate because tuples are always foreign
								| impl doesn't use only types from inside the current crate
								|
								= note: define and implement a trait or new type instead
							</script>
						</code></pre>
					</section>

					<section>
						<h2>Orphan rule¹</h2>
						<p>You can implement</p>
						<p><ul>
							<li class="fragment"><em>Local</em> traits on any type</li>
							<li class="fragment"><em>Foreign</em> traits on <em>local</em> types</li>
						</ul></p>
						<p class="fragment">This prevents ambiguous implementations.</p>
						<p><small>¹simplified, see <a href="https://doc.rust-lang.org/stable/reference/items/implementations.html?highlight=orphan%20rule#orphan-rules">the reference</a></small></p>
					</section>
					<section>
						<h2>Overlap</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
									impl<T> Identity for T {
										fn identity(self) -> Self {
											self
										}
									}

									impl Identity for i32 {
										fn identity(self) -> Self {
											self
										}
									}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers>
							<script type="text/template">
							error[E0119]: conflicting implementations of trait `Identity` for type `i32`
							--> src/main.rs:7:1
							|
							1 | impl<T> Identity for T {
								| ---------------------- first implementation here
							...
							7 | impl Identity for i32 {
								| ^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `i32`
							</script>
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Generics</h2>
					</section>
					<section>
						<h2>Trait bounds</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print<T>(value: T)
								where
									T: ToString,
								{
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								pub fn main() {
									print(1);
									print("hello");
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Trait bounds</h2>
						<ul>
							<li class="fragment">Similar to Generic Bounds in Java, TypeScript etc.
								<ul class="fragment">
									<li>Only properties of the traits can be used</li>
								</ul>
							</li>
							<li class="fragment">Other than e.g. C++ concepts
								<ul>
									<li>Only constrains callers, but duck typing still possible</li>
								</ul>
							</li>
						</ul>
						<em class="fragment"><a href="https://www.youtube.com/watch?v=E-2y1qHQvTg">Conor Hoekstra - Concepts vs Typeclasses vs Traits vs Protocols</a></em>
					</section>
					<section>
						<h2>Syntactic sugar</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print<T: ToString>(value: T) {
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: impl ToString) {
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<p><em class="fragment"><code>impl</code> is <a href="https://doc.rust-lang.org/stable/reference/types/impl-trait.html?highlight=impl%20trait#anonymous-type-parameters">not exactly</a> equivalent though</em></p>
						<p><em class="fragment">Also <code>impl</code> only works in functions and methods</em></p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer() -> impl Fn(&str) {
									|text| println!("{}", text)
								}
							</script>
						</code></pre>
						<p class="fragment"><em>Supports returning unnameable types (like closures)</em></p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> impl Fn(&str) {
									if stdout {
										|text| println!("{}", text)
									} else {
										|text| eprintln!("{}", text)
									}
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error: implementation of `FnOnce` is not general enough
								--> src/main.rs:1:34
								|
								1 | fn make_printer(stdout: bool) -> impl Fn(&str) {
								|                                  ^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough
								|
								= note: `fn(&'2 str)` must implement `FnOnce<(&'1 str,)>`, for any lifetime `'1`...
								= note: ...but it actually implements `FnOnce<(&'2 str,)>`, for some specific lifetime `'2`
							</script>
						</code></pre>
						<p class="fragment">Every path needs to return the same type.</p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> impl Fn(impl ToString) {
									|text| println!("{}", text.to_string())
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0666]: nested `impl Trait` is not allowed
								--> src/main.rs:1:30
								|
								1 | fn make_printer() -> impl Fn(impl ToString) {
								|                      --------^^^^^^^^^^^^^-
								|                      |       |
								|                      |       nested `impl Trait` here
								|                      outer `impl Trait`
							</script>
						</code></pre>
						<p class="fragment">Only <b>concrete</b> types are supported</p>
					</section>
					<section>
						<p>Both of these problems can be fixed using trait objects.</p>
						<p>More on that later.</p>
					</section>
					<section>
						<p>How is code generated from generics?</p>
					</section>
					<section>
						<h2>Monomorphisation</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: impl ToString) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print(1);
									print("hello");
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Monomorphisation</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print_i32(value: i32) {
									println!("{}", value.to_string());
								}

								fn print_str(value: &str) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print_i32(1);
									print_str("hello");
								}
							</script>
						</code></pre>
						<p>Monomorphisation = Polymorphic -> Monomorphic</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Small intermezzo</h2>
					</section>
					<section>
						<h2>Generic types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Wrapper<Wrapped> {
									wrapped: Wrapped,
								}
							</script>
						</code></pre>
						<p class="fragment">You could constrain the type definition</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Wrapper<Wrapped: Default> {
									wrapped: Wrapped,
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Generic types</h2>
						<p>But you might want to only constrain implementations</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<Wrapped: Default> Default for Wrapper<Wrapped> {
									fn default() -> Self {
										Self {
											wrapped: Wrapped::default(),
										}
									}
								}
							</script>
						</code></pre>
						<p class="fragment">This is a conditional trait implementation.</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								// useful for e.g.
								let value: Arc<Mutex<MyType> = Arc::default();
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Generic Types</h2>
						<p>This also works for regular <code>impl</code> blocks</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<Wrapped: ToString> Wrapper<Wrapped> {
									fn print(&self) {
										println!("Wrapper({})", self.wrapped.to_string());
									}
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								Wrapper { wrapped: () }.print();
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0599]: the method `print` exists for struct `Wrapper<()>`, but its trait bounds were not satisfied
								--> src/main.rs:12:26
								|
								1  | struct Wrapper<Wrapped> {
									 | ----------------------- method `print` not found for this
								...
								12 |     Wrapper { wrapped: () }.print();
									 |                             ^^^^^ method cannot be called on `Wrapper<()>` due to unsatisfied trait bounds
									 |
									 = note: the following trait bounds were not satisfied:
													 `(): ToString`
							</script>
						</code></pre>
					</section>
					<section>
						<h2>End of Intermezzo</h2>
					</section>
				</section>
				<section>
					<section>
						<h2>Trait Objects</h2>
					</section>
					<section>
						<h2>So far</h2>
						<ul>
							<li class="fragment">Monomorphisation
								<ul>
									<li>static dispatch</li>
									<li>copied implementation for every type</li>
								</ul>
							</li>
							<li class="fragment">good optimization opportunities</li>
							<li class="fragment">Can't return multiple types</li>
							<li class="fragment">Can't nest <code>impl</code></li>
						</ul>
					</section>
					<section>
						<h2>With trait objects</h2>
						<ul>
							<li class="fragment">dynamic dispatch</li>
							<li class="fragment">stops generics propagation
								<ul>
									<li class="fragment">faster compile times</li>
								</ul>
							</li>
							<li class="fragment">smaller binaries</li>
							<li class="fragment">returning different trait implementations</li>
							<li class="fragment">type erasure</li>
						</ul>
					</section>
					<section>
						<h2>Trait Objects</h2>
						<p>Works like in most popular languages</p>
						<ul>
							<li class="fragment"><b>One</b> dynamic implementation for every type</li>
							<li class="fragment">Java Interfaces</li>
							<li class="fragment">(virtual) inheritance</li>
						</ul>
					</section>
					<section>
						<h2>Owned</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: Box<dyn ToString>) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print(Box::new(1));
									print(Box::new("hello"));
								}
							</script>
						</code></pre>
						<p class="fragment">Also works with <code>Rc</code>, <code>Arc</code>, etc.</p>
						<p class="fragment"><em>Always requires heap allocation!</em></p>
					</section>
					<section>
						<h2>Borrowed</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: &dyn ToString) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print(&1);
									print(&"hello");
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Type Erasure</h2>
						<p>This now works</p>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> Box<dyn Fn(&str)> {
									if stdout {
										Box::new(|text| println!("{}", text.to_string()))
									} else {
										Box::new(|text| eprintln!("{}", text.to_string()))
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Nested <code>dyn</code></h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> Box<dyn Fn(&dyn ToString)> {
									if stdout {
										Box::new(|text| println!("{}", text.to_string()))
									} else {
										Box::new(|text| eprintln!("{}", text.to_string()))
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>What IS a trait object?</h2>
						<div class="fragment">
							<p>NOTE: Deprecated <a href="https://doc.rust-lang.org/stable/std/raw/struct.TraitObject.html">std::raw::TraitObject</a>, for demonstration only</p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
								<script type="text/template">
									#[repr(C)]
									pub struct TraitObject {
										pub data: *mut (),
										pub vtable: *mut (),
									}
								</script>
							</code></pre>
						</div>
						<ul>
							<li class="fragment">Data pointer
								<ul>
									<li>points to actual value</li>
									<li>same as normal references</li>
								</ul>
							</li>
							<li class="fragment">VTable pointer
								<ul>
									<li>points to metadata about the type</li>
								</ul>
							</li>
						</ul>
					</section>
					<section>
						<h2>VTable</h2>
						<img src="images/vtable-debugger.png"/>
						<p><em><a href="https://github.com/rust-lang/rust/blob/f9b95f92c8af07a24a870e5f6117aa5dfcee5f17/compiler/rustc_middle/src/ty/vtable.rs#L8-L22">NOTE: Unstable internals</a></em></p>
						<ul>
							<li>size</li>
							<li>alignment</li>
							<li>methods</li>
							<li>super trait vtable references</li>
						</ul>
					</section>
					<section>
						<h2>Object Safety</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn takes_default(value: Box<dyn Default>) {
									unimplemented!()
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0038]: the trait `Default` cannot be made into an object
								--> src/main.rs:1:25
								|
								1 | fn takes_default(value: Box<dyn Default>) {
									|                         ^^^^^^^^^^^^^^^^ `Default` cannot be made into an object
									|
									= note: the trait cannot be made into an object because it requires `Self: Sized`
									= note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>
							</script>
						</code></pre>
						<p class="fragment">Not all traits can be used as trait objects.</p>
					</section>
					<section>
						<h2><a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">Object safety</a></h2>
						<ol>
							<li class="fragment">supertraits must be object safe</li>
							<li class="fragment">must not require <code>Sized</code></li>
							<li class="fragment">must not have associated constants</li>
							<li class="fragment">methods must not be generic</li>
							<li class="fragment">methods must not use the <code>self</code> receiver
								<ul>
									<li><code>&self</code>, <code>Box&lt;Self&gt;</code> etc. are okay</li>
								</ul>
							</li>
							<li class="fragment">methods must have a receiver</li>
							<li class="fragment">methods must not use the <code>Self</code> type</li>
							<li class="fragment">methods must not be constrained by <code>where Self: Sized</code></li>
						</ol>
					</section>
					<section>
						<h2>But why?</h2>
					</section>
					<section>
						<ol start="1">
							<li>supertraits must be object safe</li>
						</ol>
						<p class="fragment"><em>a trait has all properties of a supertrait</em></p>
					</section>
					<section>
						<ol start="2">
							<li>must not require <code>Sized</code></li>
						</ol>
						<p class="fragment"><em>every implementation could have a different size</em></p>
						<p class="fragment">Trait objects are DSTs (dynamically sized types)</p>
					</section>
					<section>
						<ol start="3">
							<li>must not have associated constants</li>
						</ol>
					</section>
					<section>
						<h2>Associated constants</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait LimitedNumber {
									const MIN_VALUE: usize;
									const MAX_VALUE: usize;
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl LimitedNumber for u8 {
									const MIN_VALUE: usize = u8::MIN as usize;
									const MAX_VALUE: usize = u8::MAX as usize;
								}

								impl LimitedNumber for u64 {
									const MIN_VALUE: usize = u64::MIN as usize;
									const MAX_VALUE: usize = u64::MAX as usize;
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								println!("u8 min: {}", u8::MIN_VALUE);
								println!("u64 max: {}", u64::MAX_VALUE);
							</script>
						</code></pre>
					</section>
					<section>
						<ol start="3">
							<li>must not have associated constants</li>
						</ol>
						<p class="fragment"><em>every implementation could have a different constant</em></p>
						<p class="fragment"><em>therefore not available at compile time</em></p>
					</section>
					<section>
						<ol start="4">
							<li>methods must not be generic</li>
						</ol>
						<p class="fragment"><em>generic methods have infinite implementations</em></p>
						<p class="fragment"><em>the vtable can only store one</em></p>
					</section>
					<section>
						<ol start="5">
							<li class="fragment">methods must not use the <code>self</code> receiver
								<ul>
									<li><code>&self</code>, <code>Box&lt;Self&gt;</code> etc. are okay</li>
								</ul>
							</li>
						</ol>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Foo {
									fn takes_self(self);
								}
							</script>
						</code></pre>
						<div class="fragment">
							<p><em>hidden <code>Sized</code> bound</em></p>
							<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Foo {
									fn takes_self(self: Self)
									where
										Self: Sized;
								}
							</script>
						</code></pre>
						</div>
						<p class="fragment"><em>Method needs to allocate stack space for <code>self</code></em></p>
						<p class="fragment">the other receivers are just references, therefore fixed size</p>
					</section>
					<section>
						<ol start="6">
							<li>methods must have a receiver</li>
						</ol>
						<p class="fragment"><em>methods without receiver don't have a reference to <code>self</code></em></p>
						<div class="fragment">
							<p><em>therefore no access to a vtable</em></p>
							<p><em>(and the methods therein)</em></p>
						</div>
					</section>
					<section>
						<ol start="7">
							<li>methods must not use the <code>Self</code> type</li>
							<li>methods must not be constrained by <code>where Self: Sized</code></li>
						</ol>
						<p class="fragment"><em>Same hidden <code>Sized</code> bound as with <code>self</code> receiver</em></p>
					</section>
					<section>
						<h2>Is my trait object safe?</h2>
						<p class="fragment">Check with the <code>assert_obj_safe</code> macro from the <a href="https://docs.rs/static_assertions">static_assertions</a> crate</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								assert_obj_safe!(Default);
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0038]: the trait `Default` cannot be made into an object
								--> src/main.rs:2:1
								|
								2 | assert_obj_safe!(Default);
								| ^^^^^^^^^^^^^^^^^^^^^^^^^^ `Default` cannot be made into an object
								|
								= note: the trait cannot be made into an object because it requires `Self: Sized`
								= note: for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>
								= note: this error originates in the macro `assert_obj_safe` (in Nightly builds, run with -Z macro-backtrace for more info)
							</script>
						</code></pre>
					</section>
					<section>
						<h2>You choose</h2>
						<ul>
							<li class="fragment"><em>You can choose between static and dynamic dispatch for the same type</em></li>
							<li class="fragment">Examples from other languages
								<ul>
									<li class="fragment">Java, Swift etc.: Always dynamic</li>
									<li class="fragment">C++: Depends on type (<code>virtual</code> methods)</li>
								</ul>
							</li>
						</ul>
					</section>
				</section>
				<section>
					<ul>
						<li>target audience?</li>
						<li>trait method resolution</li>
						<li>marker traits</li>
						<li>generic traits</li>
						<li>associated types</li>
						<li>conditional trait methods</li>
						<li>generic associated types</li>
						<li>deriving traits</li>
						<li>More examples!!!!!!</li>
					</ul>
				</section>
			</div>
		</div>
		<script type="module" src="/main.js"></script>
	</body>
</html>

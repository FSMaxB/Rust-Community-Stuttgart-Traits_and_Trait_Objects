<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" type="image/svg+xml" href="favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Vite App</title>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Traits and Trait Objects</h1>
					<h2>More than just interfaces</h2>
					<h3>Max Bruckner</h3>
				</section>
				<section>
					<section>
						<h2>What is a trait?</h2>
					</section>
					<section>
						<h2>What is a trait?</h2>
						<ul>
							<li>Interface?</li>
							<li>Type class?</li>
							<li>Collection of methods?</li>
							<li>Shared behavior</li>
						</ul>
					</section>
					<section>
						<h2>Example</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout {
									fn shout();
								}
							</script>
						</code></pre>
					</section>
					<section>
						Traits are implemented from outside of the type itself. <em>(attached to it)</em>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Dog;

								impl Shout for Dog {
									fn shout() {
										println!("Whoof!");
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						Traits can have default implementations.

						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Shout {
									fn shout() {
										println!("The sound of silence!");
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						Traits can be implemented on <b>any</b> type.

						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl Shout for i32 {
									fn shout() {
										println!("Aren't numbers silent?")
									}
								}
							</script>
						</code></pre>
						<p class="fragment">Yes, even primitive types</p>
						<p class="fragment">Most notably: <b>Types you didn't define yourself</b></p>
					</section>
					<section>
						Traits can even be implemented on generic types.
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								trait Identity {
									fn identity(self) -> Self;
								}
							</script>
						</code></pre>

						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<T> Identity for T {
									fn identity(self) -> T {
										self
									}
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Limits</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl std::fmt::Display for () {
									...
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers>
							<script type="text/template">
								error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
								--> src/main.rs:1:1
								|
								1 | impl std::fmt::Display for () {
								| ^^^^^^^^^^^^^^^^^^^^^^^^^^^--
								| |                          |
								| |                          this is not defined in the current crate because tuples are always foreign
								| impl doesn't use only types from inside the current crate
								|
								= note: define and implement a trait or new type instead
							</script>
						</code></pre>
					</section>

					<section>
						<h2>Orphan rule¹</h2>
						<p>You can implement</p>
						<p><ul>
							<li class="fragment"><em>Local</em> traits on any type</li>
							<li class="fragment"><em>Foreign</em> traits on <em>local</em> types</li>
						</ul></p>
						<p class="fragment">This prevents ambiguous implementations.</p>
						<p><small>¹simplified, see <a href="https://doc.rust-lang.org/stable/reference/items/implementations.html?highlight=orphan%20rule#orphan-rules">the reference</a></small></p>
					</section>
					<section>
						<h2>Overlap</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
									impl<T> Identity for T {
										fn identity(self) -> Self {
											self
										}
									}

									impl Identity for i32 {
										fn identity(self) -> Self {
											self
										}
									}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers>
							<script type="text/template">
							error[E0119]: conflicting implementations of trait `Identity` for type `i32`
							--> src/main.rs:7:1
							|
							1 | impl<T> Identity for T {
								| ---------------------- first implementation here
							...
							7 | impl Identity for i32 {
								| ^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `i32`
							</script>
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Generics</h2>
					</section>
					<section>
						<h2>Trait bounds</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print<T>(value: T)
								where
									T: ToString,
								{
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								pub fn main() {
									print(1);
									print("hello");
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Trait bounds</h2>
						<ul>
							<li class="fragment">Similar to Generic Bounds in Java, TypeScript etc.
								<ul class="fragment">
									<li>Only properties of the traits can be used</li>
								</ul>
							</li>
							<li class="fragment">Other than e.g. C++ concepts
								<ul>
									<li>Only constrains callers, but duck typing still possible</li>
								</ul>
							</li>
						</ul>
						<em class="fragment"><a href="https://www.youtube.com/watch?v=E-2y1qHQvTg">Conor Hoekstra - Concepts vs Typeclasses vs Traits vs Protocols</a></em>
					</section>
					<section>
						<h2>Syntactic sugar</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print<T: ToString>(value: T) {
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: impl ToString) {
									println!("{}", value.to_string());
								}
							</script>
						</code></pre>
						<p><em class="fragment"><code>impl</code> is <a href="https://doc.rust-lang.org/stable/reference/types/impl-trait.html?highlight=impl%20trait#anonymous-type-parameters">not exactly</a> equivalent though</em></p>
						<p><em class="fragment">Also <code>impl</code> only works in functions and methods</em></p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer() -> impl Fn(&str) {
									|text| println!("{}", text)
								}
							</script>
						</code></pre>
						<p class="fragment"><em>Supports returning unnameable types (like closures)</em></p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> impl Fn(&str) {
									if stdout {
										|text| println!("{}", text)
									} else {
										|text| eprintln!("{}", text)
									}
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error: implementation of `FnOnce` is not general enough
								--> src/main.rs:1:34
								|
								1 | fn make_printer(stdout: bool) -> impl Fn(&str) {
								|                                  ^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough
								|
								= note: `fn(&'2 str)` must implement `FnOnce<(&'1 str,)>`, for any lifetime `'1`...
								= note: ...but it actually implements `FnOnce<(&'2 str,)>`, for some specific lifetime `'2`
							</script>
						</code></pre>
						<p class="fragment">Every path needs to return the same type.</p>
					</section>
					<section>
						<h2>Abstract return types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn make_printer(stdout: bool) -> impl Fn(impl ToString) {
									|text| println!("{}", text.to_string())
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0666]: nested `impl Trait` is not allowed
								--> src/main.rs:1:30
								|
								1 | fn make_printer() -> impl Fn(impl ToString) {
								|                      --------^^^^^^^^^^^^^-
								|                      |       |
								|                      |       nested `impl Trait` here
								|                      outer `impl Trait`
							</script>
						</code></pre>
						<p class="fragment">Only <b>concrete</b> types are supported</p>
					</section>
					<section>
						<p>Both of these problems can be fixed using trait objects.</p>
						<p>More on that later.</p>
					</section>
					<section>
						<p>How is code generated from generics?</p>
					</section>
					<section>
						<h2>Monomorphisation</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: impl ToString) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print(1);
									print("hello");
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Monomorphisation</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print_i32(value: i32) {
									println!("{}", value.to_string());
								}

								fn print_str(value: &str) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print_i32(1);
									print_str("hello");
								}
							</script>
						</code></pre>
						<p>Monomorphisation = Polymorphic -> Monomorphic</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Small intermezzo</h2>
					</section>
					<section>
						<h2>Generic types</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Wrapper<Wrapped> {
									wrapped: Wrapped,
								}
							</script>
						</code></pre>
						<p class="fragment">You could constrain the type definition</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								struct Wrapper<Wrapped: Default> {
									wrapped: Wrapped,
								}
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Generic types</h2>
						<p>But you might want to only constrain implementations</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<Wrapped: Default> Default for Wrapper<Wrapped> {
									fn default() -> Self {
										Self {
											wrapped: Wrapped::default(),
										}
									}
								}
							</script>
						</code></pre>
						<p class="fragment">This is a conditional trait implementation.</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								// useful for e.g.
								let value: Arc<Mutex<MyType> = Arc::default();
							</script>
						</code></pre>
					</section>
					<section>
						<h2>Generic Types</h2>
						<p>This also works for regular <code>impl</code> blocks</p>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								impl<Wrapped: ToString> Wrapper<Wrapped> {
									fn print(&self) {
										println!("Wrapper({})", self.wrapped.to_string());
									}
								}
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								Wrapper { wrapped: () }.print();
							</script>
						</code></pre>
						<pre class="fragment"><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								error[E0599]: the method `print` exists for struct `Wrapper<()>`, but its trait bounds were not satisfied
								--> src/main.rs:12:26
								|
								1  | struct Wrapper<Wrapped> {
									 | ----------------------- method `print` not found for this
								...
								12 |     Wrapper { wrapped: () }.print();
									 |                             ^^^^^ method cannot be called on `Wrapper<()>` due to unsatisfied trait bounds
									 |
									 = note: the following trait bounds were not satisfied:
													 `(): ToString`
							</script>
						</code></pre>
					</section>
					<section>
						<h2>End of Intermezzo</h2>
					</section>
				</section>
				<section>
					<section>
						<h2>Trait Objects</h2>
					</section>
					<section>
						<h2>So far</h2>
						<ul>
							<li class="fragment">Monomorphisation
								<ul>
									<li>static dispatch</li>
									<li>copied implementation for every type</li>
								</ul>
							</li>
							<li class="fragment">good optimization opportunities</li>
							<li class="fragment">Can't return multiple types</li>
							<li class="fragment">Can't nest <code>impl</code></li>
						</ul>
					</section>
					<section>
						<h2>With trait objects</h2>
						<ul>
							<li class="fragment">dynamic dispatch</li>
							<li class="fragment">stops generics propagation
								<ul>
									<li class="fragment">faster compile times</li>
								</ul>
							</li>
							<li class="fragment">smaller binaries</li>
							<li class="fragment">returning different trait implementations</li>
						</ul>
					</section>
					<section>
						<h2>Trait Objects</h2>
						<p>Works like in most popular languages</p>
						<ul>
							<li class="fragment"><b>One</b> dynamic implementation for every type</li>
							<li class="fragment">Java Interfaces</li>
							<li class="fragment">(virtual) inheritance</li>
						</ul>
					</section>
					<section>
						<h2>Owned</h2>
						<pre><code data-trim data-noescape data-line-numbers class="language-rust">
							<script type="text/template">
								fn print(value: Box<dyn ToString>) {
									println!("{}", value.to_string());
								}

								pub fn main() {
									print(Box::new(1));
									print(Box::new("hello"));
								}
							</script>
						</code></pre>
						<p class="fragment">Also works with <code>Rc</code>, <code>Arc</code>, etc.</p>
						<p class="fragment"><em>Always requires heap allocation!</em></p>
					</section>
					<section>
						<h2>Borrowed</h2>
						TODO
					</section>
				</section>
				<section>
					<ul>
						<li>target audience?</li>
						<li>trait method resolution</li>
						<li>marker traits</li>
						<li>generic traits</li>
						<li>associated types</li>
						<li>associated consts</li>
						<li>generic associated types</li>
						<li>trait objects</li>
						<li>object safety</li>
						<li>fat pointers</li>
						<li>vtable</li>
						<li>static vs. dynamic dispatch</li>
						<li>deriving traits</li>
						<li>More examples!!!!!!</li>
					</ul>
				</section>
			</div>
		</div>
		<script type="module" src="/main.js"></script>
	</body>
</html>
